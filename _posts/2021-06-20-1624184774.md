---
title: spring整合redis缓存，以注解(@Cacheable、@CachePut、@CacheEvict)形式使用
categories: redis
tags: redis spring-data-redis jedis Cacheable 缓存
---
maven项目中在pom.xml中依赖2个jar包，其他的spring的jar包省略：

    
    
    <dependency>
       <groupId>redis.clients</groupId>
       <artifactId>jedis</artifactId>
       <version>2.8.1</version>
    </dependency>
    <dependency>
       <groupId>org.springframework.data</groupId>
       <artifactId>spring-data-redis</artifactId>
       <version>1.7.2.RELEASE</version>
    </dependency>

spring-redis.xml中的内容：

    
    
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"  
        xmlns:context="http://www.springframework.org/schema/context"  
        xmlns:mvc="http://www.springframework.org/schema/mvc"  
        xmlns:cache="http://www.springframework.org/schema/cache"
        xsi:schemaLocation="http://www.springframework.org/schema/beans    
                            http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    
                            http://www.springframework.org/schema/context    
                            http://www.springframework.org/schema/context/spring-context-4.2.xsd    
                            http://www.springframework.org/schema/mvc    
                            http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
                            http://www.springframework.org/schema/cache 
                            http://www.springframework.org/schema/cache/spring-cache-4.2.xsd"> 
        
        <context:property-placeholder location="classpath:redis-config.properties" />  
    
        <!-- 启用缓存注解功能，这个是必须的，否则注解不会生效，另外，该注解一定要声明在spring主配置文件中才会生效 -->  
        <cache:annotation-driven cache-manager="cacheManager" />  
        
         <!-- redis 相关配置 -->  
         <bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig">  
             <property name="maxIdle" value="${redis.maxIdle}" />   
             <property name="maxWaitMillis" value="${redis.maxWait}" />  
             <property name="testOnBorrow" value="${redis.testOnBorrow}" />  
         </bean>  
    
         <bean id="JedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"  
           p:host-name="${redis.host}" p:port="${redis.port}" p:password="${redis.pass}" p:pool-config-ref="poolConfig"/>  
      
         <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate">  
             <property name="connectionFactory" ref="JedisConnectionFactory" />  
         </bean>  
        
         <!-- spring自己的缓存管理器，这里定义了缓存位置名称 ，即注解中的value -->  
         <bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager">  
             <property name="caches">  
                <set>  
                    <!-- 这里可以配置多个redis -->
                    <!-- <bean class="com.cn.util.RedisCache">  
                         <property name="redisTemplate" ref="redisTemplate" />  
                         <property name="name" value="default"/>  
                    </bean> -->  
                    <bean class="com.cn.util.RedisCache">  
                         <property name="redisTemplate" ref="redisTemplate" />  
                         <property name="name" value="common"/>  
                         <!-- common名称要在类或方法的注解中使用 -->
                    </bean>
                </set>  
             </property>  
         </bean>  
        
    </beans>  

redis-config.properties中的内容：

    
    
    # Redis settings
    # server IP
    redis.host=127.0.0.1
    # server port
    redis.port=6379
    # server pass
    redis.pass=
    # use dbIndex
    redis.database=0
    # 控制一个pool最多有多少个状态为idle(空闲的)的jedis实例
    redis.maxIdle=300
    # 表示当borrow(引入)一个jedis实例时，最大的等待时间，如果超过等待时间(毫秒)，则直接抛出JedisConnectionException；  
    redis.maxWait=3000
    # 在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的  
    redis.testOnBorrow=true

com.cn.util.RedisCache类中的内容：

    
    
    package com.cn.util;
    
    import java.io.ByteArrayInputStream;
    import java.io.ByteArrayOutputStream;
    import java.io.IOException;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    
    import org.springframework.cache.Cache;
    import org.springframework.cache.support.SimpleValueWrapper;
    import org.springframework.dao.DataAccessException;
    import org.springframework.data.redis.connection.RedisConnection;
    import org.springframework.data.redis.core.RedisCallback;
    import org.springframework.data.redis.core.RedisTemplate;
    
    public class RedisCache implements Cache{
    
    	private RedisTemplate<String, Object> redisTemplate;  
        private String name;  
        public RedisTemplate<String, Object> getRedisTemplate() {
    	    return redisTemplate;  
    	}
    	 
    	public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {
    	    this.redisTemplate = redisTemplate;  
    	}
    	 
    	public void setName(String name) {
    	    this.name = name;  
        }
    	 
        @Override  
        public String getName() {
           // TODO Auto-generated method stub  
            return this.name;  
        }
    
        @Override  
        public Object getNativeCache() {
          // TODO Auto-generated method stub  
            return this.redisTemplate;  
        }
     
        @Override  
        public ValueWrapper get(Object key) {
          // TODO Auto-generated method stub
          System.out.println("get key");
          final String keyf =  key.toString();
          Object object = null;
          object = redisTemplate.execute(new RedisCallback<Object>() {
          public Object doInRedis(RedisConnection connection)  
                      throws DataAccessException {
              byte[] key = keyf.getBytes();
              byte[] value = connection.get(key);
              if (value == null) {
                 return null;
                }
              return toObject(value);
              }
           });
            return (object != null ? new SimpleValueWrapper(object) : null);
          }
      
         @Override  
         public void put(Object key, Object value) {
           // TODO Auto-generated method stub
           System.out.println("put key");
           final String keyf = key.toString();  
           final Object valuef = value;  
           final long liveTime = 86400;  
           redisTemplate.execute(new RedisCallback<Long>() {  
               public Long doInRedis(RedisConnection connection)  
                       throws DataAccessException {  
                    byte[] keyb = keyf.getBytes();  
    	            byte[] valueb = toByteArray(valuef);  
    	            connection.set(keyb, valueb);  
    	            if (liveTime > 0) {  
    	                connection.expire(keyb, liveTime);  
                     }  
                    return 1L;  
                 }  
             });  
          }
    
          private byte[] toByteArray(Object obj) {  
             byte[] bytes = null;  
             ByteArrayOutputStream bos = new ByteArrayOutputStream();  
             try {  
               ObjectOutputStream oos = new ObjectOutputStream(bos);  
               oos.writeObject(obj);  
               oos.flush();  
               bytes = bos.toByteArray();  
               oos.close();  
               bos.close();  
    	      }catch (IOException ex) {  
    	           ex.printStackTrace();  
    	      }  
    	      return bytes;  
    	    }  
    
    	   private Object toObject(byte[] bytes) {
             Object obj = null;  
    	       try {
    	           ByteArrayInputStream bis = new ByteArrayInputStream(bytes);  
    	           ObjectInputStream ois = new ObjectInputStream(bis);  
    	           obj = ois.readObject();  
    	           ois.close();  
    	           bis.close();  
    	       } catch (IOException ex) {  
    	           ex.printStackTrace();  
    	        } catch (ClassNotFoundException ex) {  
    	           ex.printStackTrace();  
    	        }  
    	        return obj;  
            }
      
           @Override  
           public void evict(Object key) {  
             // TODO Auto-generated method stub  
        	 System.out.println("del key");
             final String keyf = key.toString();  
             redisTemplate.execute(new RedisCallback<Long>() {  
             public Long doInRedis(RedisConnection connection)  
                       throws DataAccessException {  
                 return connection.del(keyf.getBytes());  
                }  
              });  
            }
     
    	    @Override  
    	    public void clear() {  
    	       // TODO Auto-generated method stub  
    	    	System.out.println("clear key");
    	       redisTemplate.execute(new RedisCallback<String>() {  
    	            public String doInRedis(RedisConnection connection)  
    	                    throws DataAccessException {  
    	              connection.flushDb();  
    	                return "ok";  
    	           }  
    	       });  
    	    }
    
    		@Override
    		public <T> T get(Object key, Class<T> type) {
    			// TODO Auto-generated method stub
    			return null;
    		}
    	
    		@Override
    		public ValueWrapper putIfAbsent(Object key, Object value) {
    			// TODO Auto-generated method stub
    			return null;
    		}
    
    }
    

到了这一步，大部分人会想在web.xml的启动配置文件地方(context-param)加入了spring-
redis.xml,让项目启动时加载这个配置文件吧，但是这样启动后注解不生效。

正确的做法是：web.xml中配置了servlet控制器：

    
    
      <servlet>
        <servlet-name>SpringMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>/WEB-INF/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <async-supported>true</async-supported>
      </servlet>

在DispatcherServlet的初始化过程中，框架会在web应用的 WEB-INF文件夹下寻找名为spring-
mvc.xml的配置文件，如果不指定的话，默认是applicationContext.xml

只需要在spring-mvc.xml文件中引入spring-redis配置文件即可，正如spring-
redis.xml中的启用注解说的：<cache:annotation-driven cache-manager="cacheManager"
/>注解一定要声明在spring主配置文件中才会生效。

spring-mvc.xml内容，省略了spring与spring MVC整合的那部分：

    
    
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"  
        xmlns:context="http://www.springframework.org/schema/context"  
        xmlns:mvc="http://www.springframework.org/schema/mvc"  
        xsi:schemaLocation="http://www.springframework.org/schema/beans    
                            http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    
                            http://www.springframework.org/schema/context    
                            http://www.springframework.org/schema/context/spring-context-4.2.xsd    
                            http://www.springframework.org/schema/mvc    
                            http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd">
        <!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 -->  
        <context:component-scan base-package="com.cn" />  
        
        <!-- 引入同文件夹下的redis属性配置文件 -->
        <import resource="spring-redis.xml"/>
        
    </beans>  

在service的实现类中：

    
    
    @Service
    public class UserServiceImpl implements UserService{
    
    	@Autowired
    	private UserBo userBo;
    
    	@Cacheable(value="common",key="'id_'+#id")
    	public User selectByPrimaryKey(Integer id) {
    		return userBo.selectByPrimaryKey(id);
    	}
    	
    	@CachePut(value="common",key="#user.getUserName()")
    	public void insertSelective(User user) {
    		userBo.insertSelective(user);
    	}
    
    	@CacheEvict(value="common",key="'id_'+#id")
    	public void deleteByPrimaryKey(Integer id) {
    		userBo.deleteByPrimaryKey(id);
    	}
    }
    

