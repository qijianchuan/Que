---
title: RabbitMQ的Android端接收
categories: android
tags: android RabbitMQ
---
本次做的项目，有一部分是通过RabbitMQ来传输的实时数据。然后我这Android端就需要研究怎么接收。以前用的volley什么的，都是用http通讯的，这个稍微不太一样，采用的消息队列的方式，生产者与消费者的设计模式，观察者模式。有次面试就挂这了TT。

看了下RabbitMQ，可以服务端上可以设置为

  * 工作队列（Work queues）这种模式下，只有一个消息队列，但是有多个消费者，这样每个任务只会被一个消费者处理

  * 订阅发布模式（Publish/Subscribe）这种模式下，会有多个队列，每个队列都有一个消费者

我们项目中服务端应该用的就是Publish/Subscribe这种。  
![这里写图片描述](data:image/png;base64,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)  
从官网盗图

除了生产者、消费者、消息队列这些东西外，还多了一个X，这个X指的是Exchanges（可以翻译成交换机）。

在这种模式下，生产者不直接把信息发送给消息队列，而是只发送给Exchanges，由Exchanges转发给每个消息队列。

Exchanges收到信息后会进行一些处理，比如这个消息我都应该发送给哪些队列，还是只发送给一个队列，还是应该丢弃这个消息。这样每个消息队列从Exchanges收到的东西可能都不一样，收到的消息都是根据每个消息队列的需求定制的。比如我们项目分为了油车和电车两种，可以有两个消息队列，一个消息队列只收油车数据，一个只收电车数据。这样根据需要，我在客户端这可以指定我只接受电车的数据了，我就可以从只收电车数据的这个消息队列里取了。

然后开始实现：  
https://www.cloudamqp.com/blog/2015-07-29-rabbitmq-on-android.html  
在这发现了一篇好教程，直接教我怎么在Android上实现。

代码不多，很容易就可以实现。  
我把代码精简了下，因为我这只需要从服务器接收数据就可以了，所以把publish的代码删了

主要流程如下：

  1. 设置连接参数setupConnectionFactory
  2. 创建一个用于从线程中接收数据来更新UI的handler
  3. 启动一个订阅者线程，创建一个队列，将其bind到参数中指定的Exchanges上，并根据传入的routingKey路由关键字来从Exchanges中接收指定类型的消息数据。
  4. 之后创建消费者consumer从消息队列中循环请求数据。

    
    
    package edu.hrbeu.ice.rabbitmqclient;
    
    import android.os.Bundle;
    import android.os.Handler;
    import android.os.Message;
    import android.support.v7.app.AppCompatActivity;
    import android.util.Log;
    import android.view.View;
    import android.widget.Button;
    import android.widget.EditText;
    import android.widget.TextView;
    
    import com.rabbitmq.client.AMQP;
    import com.rabbitmq.client.Channel;
    import com.rabbitmq.client.Connection;
    import com.rabbitmq.client.ConnectionFactory;
    import com.rabbitmq.client.QueueingConsumer;
    
    import java.net.URISyntaxException;
    import java.security.KeyManagementException;
    import java.security.NoSuchAlgorithmException;
    import java.text.SimpleDateFormat;
    import java.util.Date;
    import java.util.concurrent.BlockingDeque;
    import java.util.concurrent.LinkedBlockingDeque;
    
    public class MainActivity extends AppCompatActivity {
    
        ConnectionFactory factory = new ConnectionFactory();
        Thread subscribeThread;
    
    
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
    
            //连接设置
            setupConnectionFactory();
    
            //用于从线程中获取数据，更新ui
            final Handler incomingMessageHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    String message = msg.getData().getString("msg");
                    TextView tv = (TextView) findViewById(R.id.textView);
                    Date now = new Date();
                    SimpleDateFormat ft = new SimpleDateFormat("hh:mm:ss");
                    tv.append(ft.format(now) + ' ' + message + '\n');
                    Log.i("test", "msg:" + message);
                }
            };
            //开启消费者线程
            subscribe(incomingMessageHandler);
        }
    
        /**
         * 连接设置
         */
        private void setupConnectionFactory() {
            factory.setHost("server url");
            factory.setPort(5671);
            factory.setUsername("guest");
            factory.setPassword("guest");
        }
    
        /**
         * 消费者线程
         */
        void subscribe(final Handler handler) {
            subscribeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            //使用之前的设置，建立连接
                            Connection connection = factory.newConnection();
                            //创建一个通道
                            Channel channel = connection.createChannel();
                            //一次只发送一个，处理完成一个再获取下一个
                            channel.basicQos(1);
    
                            AMQP.Queue.DeclareOk q = channel.queueDeclare();
                            //将队列绑定到消息交换机exchange上
                            //                  queue         exchange              routingKey路由关键字，exchange根据这个关键字进行消息投递。
                            channel.queueBind(q.getQueue(), "amq.fanout", "chat");
    
                            //创建消费者
                            QueueingConsumer consumer = new QueueingConsumer(channel);
                            channel.basicConsume(q.getQueue(), true, consumer);
    
                            while (true) {
                                //wait for the next message delivery and return it.
                                QueueingConsumer.Delivery delivery = consumer.nextDelivery();
                                String message = new String(delivery.getBody());
    
                                Log.d("", "[r] " + message);
    
                                //从message池中获取msg对象更高效
                                Message msg = handler.obtainMessage();
                                Bundle bundle = new Bundle();
                                bundle.putString("msg", message);
                                msg.setData(bundle);
                                handler.sendMessage(msg);
                            }
                        } catch (InterruptedException e) {
                            break;
                        } catch (Exception e1) {
                            Log.d("", "Connection broken: " + e1.getClass().getName());
                            try {
                                Thread.sleep(5000); //sleep and then try again
                            } catch (InterruptedException e) {
                                break;
                            }
                        }
                    }
                }
            });
            subscribeThread.start();
        }
    
        @Override
        protected void onDestroy() {
            super.onDestroy();
            subscribeThread.interrupt();
        }
    
    }
    

源码地址

