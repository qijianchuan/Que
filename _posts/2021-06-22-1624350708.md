---
title: MongoDB之——索引
categories: 精通分布式数据库系列
tags: MongoDB
---
转载请注明出处：https://blog.csdn.net/l1028386804/article/details/80003156  

MongoDB 提供了多样性的索引支持，索引信息被保存在 system.indexes 中，且默认总是为_id创建索引，它的索引使用基本和 MySQL
等关系型数据库一样。其实可以这样说说，索引是凌驾于数据存储系统之上的另一层系统，所以各种结构迥异的存储都有相同或相似的索引实现及使用接口并不足为奇。  

### 1、基础索引

在字段 age 上创建索引， 1(升序);-1(降序)  

    
    
    > db.t3.ensureIndex({age:1})
    > db.t3.getIndexes();
    [
    {
    "name" : "_id_",
    "ns" : "test.t3",
    "key" : {
    "_id" : 1
    },
    "v" : 0
    },
    {
    "_id" : ObjectId("4fb906da0be632163d0839fe"),
    "ns" : "test.t3",
    "key" : {
    "age" : 1
    },
    "name" : "age_1",
    "v" : 0
    }
    ]
    >

上例显示出来的一共有 2 个索引，其中_id
是创建表的时候自动创建的索引，此索引是不能够删除的。当系统已有大量数据时，创建索引就是个非常耗时的活，我们可以在后台执行，只需指定“backgroud:true”即可。  

    
    
    > db.t3.ensureIndex({age:1} , {backgroud:true})

### 2、文档索引

索引可以任何类型的字段，甚至文档  

    
    
    db.factories.insert( { name: "wwl", addr: { city: "Beijing", state: "BJ" } } );
    
    
    //在 addr 列上创建索引
    db.factories.ensureIndex( { addr : 1 } );
    //下面这个查询将会用到我们刚刚建立的索引
    db.factories.find( { addr: { city: "Beijing", state: "BJ" } } );
    //但是下面这个查询将不会用到索引，因为查询的顺序跟索引建立的顺序不一样
    db.factories.find( { addr: { state: "BJ" , city: "Beijing"} } );

### 3、组合索引

跟其它数据库产品一样， MongoDB 也是有组合索引的，下面我们将在 addr.city 和
addr.state上建立组合索引。当创建组合索引时，字段后面的 1 表示升序， -1 表示降序，是用 1 还是用-1 主要是跟排序的时候或指定范围内查询
的时候有关的。  

    
    
    db.factories.ensureIndex( { "addr.city" : 1, "addr.state" : 1 } );
    // 下面的查询都用到了这个索引
    db.factories.find( { "addr.city" : "Beijing", "addr.state" : "BJ" } );
    db.factories.find( { "addr.city" : "Beijing" } );
    db.factories.find().sort( { "addr.city" : 1, "addr.state" : 1 } );
    db.factories.find().sort( { "addr.city" : 1 } )

### 4、唯一索引

只需在 ensureIndex 命令中指定”unique:true”即可创建唯一索引。例如，往表 t4 中插入 2 条记录  

    
    
    db.t4.insert({firstname: "liu", lastname: "yazhuang"});
    db.t4.insert({firstname: "liu", lastname: "yazhuang"});

在 t4 表中建立唯一索引  

    
    
    > db.t4.ensureIndex({firstname: 1, lastname: 1}, {unique: true});
    E11000 duplicate key error index: test.t4.$firstname_1_lastname_1 dup key: { : "liu", :"yazhuang" }

可以看到，当建唯一索引时，系统报了“表里有重复值”的错，具体原因就是因为表中有 2条一模一模的数据，所以建立不了唯一索引  

### 5、强制使用索引

hint 命令可以强制使用某个索引。  

    
    
    > db.t5.insert({name: "liuyazhuang",age: 20})
    > db.t5.ensureIndex({name:1, age:1})
    > db.t5.find({age:{$lt:30}}).explain()
    {
    	"cursor" : "BasicCursor",
    	"nscanned" : 1,
    	"nscannedObjects" : 1,
    	"n" : 1,
    	"millis" : 0,
    	"nYields" : 0,
    	"nChunkSkips" : 0,
    	"isMultiKey" : false,
    	"indexOnly" : false,
    	"indexBounds" : { --并没有用到索引
    	}
    }
    > db.t5.find({age:{$lt:30}}).hint({name:1, age:1}).explain() --强制使用索引
    {
    	"cursor" : "BtreeCursor name_1_age_1",
    	"nscanned" : 1,
    	"nscannedObjects" : 1,
    	"n" : 1,
    	"millis" : 1,
    	"nYields" : 0,
    	"nChunkSkips" : 0,
    	"isMultiKey" : false,
    	"indexOnly" : false,
    	"indexBounds" : { --被强制使用索引了
    		"name" : [
    			[
    				{
    					"$minElement" : 1
    				},
    				{
    					"$maxElement" : 1
    				}
    			]
    		],
    		"age" : [
    			[
    				-1.7976931348623157e+308,
    				30
    			]
    		]
    	}
    }
    >

### 6、删除索引

删除索引分为删除某张表的所有索引和删除某张表的某个索引，具体如下：  

    
    
    //删除 t3 表中的所有索引
    db.t3.dropIndexes()
    //删除 t4 表中的 firstname 索引
    db.t4.dropIndex({firstname: 1})

  

