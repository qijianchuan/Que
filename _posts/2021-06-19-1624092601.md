---
title: java并发实现_Java并发实现原理:JDK源码剖析
categories: 
tags: java并发实现
---
本书全面系统地讲解了Java并发实现原理，从基础的多线程知识讲起，全面介绍了Concurrent包的每个部分，详细分析多线程背后的原理，同时从源码角度进行了剖析，为的一本好书。

本书全面而系统地剖析了Java
Concurrent包中的每一个部分，对并发的实现原理进行了深刻的探讨。全书分为8章，章从很基础的多线程知识讲起，理清多线程中容易误解的知识点，探究背后的原理，包括内存重排序、happen-
before、内存屏障等；第2~8章，从简单到复杂，逐个剖析Concurrent包的每个部分，包括原子类、锁、同步工具类、并发容器、线程池、ForkJoinPool、CompletableFuture共7个部分。本书遵循层层递进的逻辑，后一章建立在前一章的知识点基础之上，建议读者由浅入深，逐步深入阅读。本书适合有一定Java开发经验的工程师、架构师阅读。通过本书，读者可以对多线程编程形成一个“深刻而直观”的认识，而不是再仅仅停留在概念和理论层面。

中科院软件所计算机硕士毕业。热衷于高并发高可用架构、业务建模、领域驱动设计，在十年的工作中，经历过游戏、社交、广告、电商等各种类型的项目，积累了较丰富的工程经验。

章 多线程基础 / 11.1 线程的优雅关闭 / 11.1.1 stop与destory函数 / 11.1.2 守护线程 / 11.1.3 设置关闭的标志位
/ 21.2 InterruptedException与interrupt()函数 / 31.2.1 什么情况下会抛出Interrupted异常 /
31.2.2 轻量级阻塞与重量级阻塞 / 41.2.3 t.isInterrupted()与Thread.interrupted()的区别 / 51.3
synchronized关键字 / 51.3.1 锁的对象是什么 / 51.3.2 锁的本质是什么 / 61.3.3 synchronized实现原理 /
71.4 wait与notify / 71.4.1 生产者?消费者模型 / 71.4.2 为什么必须和synchornized一起使用 / 81.4.3
为什么wait()的时候必须释放锁 / 91.4.4 wait()与notify()的问题 / 101.5 volatile关键字 / 111.5.1
64位写入的原子性(Half Write) / 111.5.2 内存可见性 / 111.5.3 重排序：DCL问题 / 121.6 JMM与happen-
before / 131.6.1 为什么会存在“内存可见性”问题 / 131.6.2 重排序与内存可见性的关系 / 151.6.3 as-if-
serial语义 / 161.6.4 happen-before是什么 / 171.6.5 happen-before的传递性 / 181.6.6
C++中的volatile关键字 / 191.6.7 JSR-133对volatile语义的增强 / 201.7 内存屏障 / 201.7.1
Linux中的内存屏障 / 211.7.2 JDK中的内存屏障 / 231.7.3 volatile实现原理 / 241.8 final关键字 /
251.8.1 构造函数溢出问题 / 251.8.2 final的happen-before语义 / 261.8.3 happen-before规则总结 /
261.9 综合应用：无锁编程 / 271.9.1 一写一读的无锁队列：内存屏障 / 271.9.2 一写多读的无锁队列：volatile关键字 /
271.9.3 多写多读的无锁队列：CAS / 281.9.4 无锁栈 / 281.9.5 无锁链表 / 28第2章 Atomic类 / 292.1
AtomicInteger和AtomicLong / 292.1.1 悲观锁与乐观锁 / 312.1.2 Unsafe 的CAS详解 / 312.1.3
自旋与阻塞 / 322.2 AtomicBoolean和AtomicReference / 332.2.1 为什么需要AtomicBoolean /
332.2.2 如何支持boolean和double类型 / 332.3 AtomicStampedReference和AtomicMarkable
Reference / 342.3.1 ABA问题与解决办法 / 342.3.2
为什么没有AtomicStampedInteger或AtomictStampedLong / 352.3.3 AtomicMarkableReference
/ 362.4 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceField
Updater / 372.4.1 为什么需要AtomicXXXFieldUpdater / 372.4.2 限制条件 / 382.5
AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray / 382.5.1 使用方式 /
382.5.2 实现原理 / 392.6 Striped64与LongAdder / 402.6.1 LongAdder原理 / 402.6.2 最终一致性
/ 412.6.3 伪共享与缓存行填充 / 422.6.4 LongAdder核心实现 / 432.6.5 LongAccumulator /
472.6.6 DoubleAdder与DoubleAccumulator / 47第3章 Lock与Condition / 493.1 互斥锁 /
493.1.1 锁的可重入性 / 493.1.2 类继承层次 / 493.1.3 锁的公平性vs.非公平性 / 513.1.4 锁实现的基本原理 /
513.1.5 公平与非公平的lock()实现差异 / 533.1.6 阻塞队列与唤醒机制 / 553.1.7 unlock()实现分析 / 583.1.8
lockInterruptibly()实现分析 / 593.1.9 tryLock()实现分析 / 603.2 读写锁 / 603.2.1 类继承层次 /
603.2.2 读写锁实现的基本原理 / 613.2.3 AQS的两对模板方法 / 623.2.4 WriteLock公平vs.非公平实现 /
653.2.5 ReadLock公平vs.非公平实现 / 673.3 Condition / 683.3.1 Condition与Lock的关系 /
683.3.2 Condition的使用场景 / 693.3.3 Condition实现原理 / 713.3.4 await()实现分析 / 723.3.5
awaitUninterruptibly()实现分析 / 733.3.6 notify()实现分析 / 743.4 StampedLock /
753.4.1 为什么引入StampedLock / 753.4.2 使用场景 / 753.4.3 “乐观读”的实现原理 / 773.4.4
悲观读/写：“阻塞”与“自旋”策略实现差异 / 78第4章 同步工具类 / 834.1 Semaphore / 834.2 CountDownLatch /
844.2.1 CountDownLatch使用场景 / 844.2.2 await()实现分析 / 854.2.3 countDown()实现分析 /
854.3 CyclicBarrier / 864.3.1 CyclicBarrier使用场景 / 864.3.2 CyclicBarrier实现原理 /
874.4 Exchanger / 904.4.1 Exchanger使用场景 / 904.4.2 Exchanger 实现原理 / 914.4.3
exchange(V x)实现分析 / 924.5 Phaser / 944.5.1
用Phaser替代CyclicBarrier和CountDownLatch / 944.5.2 Phaser新特性 / 954.5.3 state变量解析
/ 964.5.4 阻塞与唤醒(Treiber Stack) / 984.5.5 arrive()函数分析 / 994.5.6
awaitAdvance()函数分析 / 101第5章 并发容器 / 1045.1 BlockingQueue / 1045.1.1
ArrayBlockingQueue / 1055.1.2 LinkedBlockingQueue / 1065.1.3
PriorityBlockingQueue / 1095.1.4 DelayQueue / 1115.1.5 SynchronousQueue /
1135.2 BlockingDeque / 1215.3 CopyOnWrite / 1235.3.1 CopyOnWriteArrayList /
1235.3.2 CopyOnWriteArraySet / 1245.4 ConcurrentLinkedQueue/ Deque / 1255.5
ConcurrentHashMap / 1305.5.1 JDK 7中的实现方式 / 1305.5.2 JDK 8中的实现方式 / 1385.6
ConcurrentSkipListMap/Set / 1525.6.1 ConcurrentSkipListMap / 1535.6.2
ConcurrentSkipListSet / 162第6章 线程池与Future / 1636.1 线程池的实现原理 / 1636.2 线程池的类继承体系
/ 1646.3 ThreadPoolExecutor / 1656.3.1 核心数据结构 / 1656.3.2 核心配置参数解释 / 1656.3.3
线程池的优雅关闭 / 1676.3.4 任务的提交过程分析 / 1726.3.5 任务的执行过程分析 / 1746.3.6 线程池的4种拒绝策略 /
1796.4 Callable与Future / 1806.5 ScheduledThreadPool Executor / 1836.5.1
延迟执行和周期性执行的原理 / 1846.5.2 延迟执行 / 1846.5.3 周期性执行 / 1856.6 Executors工具类 / 188第7章
ForkJoinPool / 1907.1 ForkJoinPool用法 / 1907.2 核心数据结构 / 1937.3 工作窃取队列 / 1957.4
ForkJoinPool状态控制 / 1987.4.1 状态变量ctl解析 / 1987.4.2 阻塞栈Treiber Stack / 2007.4.3
ctl变量的初始值 / 2017.4.4 ForkJoinWorkerThread状态与个数分析 / 2017.5 Worker线程的阻塞-唤醒机制 /
2027.5.1 阻塞？入栈 / 2027.5.2 唤醒？出栈 / 2047.6 任务的提交过程分析 / 2057.6.1 内部提交任务pushTask /
2067.6.2 外部提交任务addSubmission / 2067.7 工作窃取算法：任务的执行过程分析 / 2077.7.1 顺序锁 SeqLock
/ 2097.7.2 scanGuard解析 / 2107.8 ForkJoinTask的fork/join / 2127.8.1 fork /
2137.8.2 join的层层嵌套 / 2137.9 ForkJoinPool的优雅关闭 / 2227.9.1 关键的terminate变量 /
2227.9.2 shutdown()与shutdownNow()的区别 / 223第8章 CompletableFuture / 2268.1
CompletableFuture用法 / 2268.1.1 最简单的用法 / 2268.1.2 提交任务：runAsync与supplyAsync /
2268.1.3 链式的CompletableFuture：thenRun、thenAccept和thenApply / 2278.1.4
CompletableFuture的组合：thenCompose与thenCombine / 2298.1.5
任意个CompletableFuture的组合 / 2318.2 四种任务原型 / 2338.3 CompletionStage接口 / 2338.4
CompletableFuture内部原理 / 2348.4.1 CompletableFuture的构造：ForkJoinPool / 2348.4.2
任务类型的适配 / 2358.4.3 任务的链式执行过程分析 / 2378.4.4 thenApply与thenApplyAsync的区别 / 2418.5
任务的网状执行：有向无环图 / 2428.6 allOf内部的计算图分析 / 244

