---
title: spring 整合redis 使用配置类方式
categories: java基础
tags: java redis
---
# spring 整合redis 使用配置类方式

导入maven依赖：

    
    
    <dependency>
      <groupId>redis.clients</groupId>
           <artifactId>jedis</artifactId>
           <version>3.3.0</version>
       </dependency>
       <dependency>
           <groupId>org.springframework.data</groupId>
           <artifactId>spring-data-redis</artifactId>
           <version>2.3.2.RELEASE</version>
    </dependency>
    

配置类：

    
    
    @Configuration
    public class RedisConfig {
        @Bean
        public JedisPoolConfig jedisPoolConfig() {
            JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
            //最大连接数
            jedisPoolConfig.setMaxTotal(100);
            //最小空闲连接数
            jedisPoolConfig.setMinIdle(20);
            //当池内没有可用的连接时，最大等待时间
            jedisPoolConfig.setMaxWaitMillis(10000);
            //------其他属性根据需要自行添加-------------
            return jedisPoolConfig;
        }
    
        @Bean
        public RedisConnectionFactory redisConnectionFactory(JedisPoolConfig jedisPoolConfig) {
            //单机版jedis
            RedisStandaloneConfiguration redisStandaloneConfiguration =
                    new RedisStandaloneConfiguration();
            //设置redis服务器的host或者ip地址
            redisStandaloneConfiguration.setHostName("127.0.0.1");
            //设置默认使用的数据库
            redisStandaloneConfiguration.setDatabase(0);
            //设置密码
            // redisStandaloneConfiguration.setPassword(RedisPassword.of("123456"));
            //设置redis的服务的端口号
            redisStandaloneConfiguration.setPort(6379);
            //获得默认的连接池构造器(怎么设计的，为什么不抽象出单独类，供用户使用呢)
            JedisClientConfiguration.JedisPoolingClientConfigurationBuilder jpcb =
                    (JedisClientConfiguration.JedisPoolingClientConfigurationBuilder)JedisClientConfiguration.builder();
            //指定jedisPoolConifig来修改默认的连接池构造器（真麻烦，滥用设计模式！）
            jpcb.poolConfig(jedisPoolConfig);
            //通过构造器来构造jedis客户端配置
            JedisClientConfiguration jedisClientConfiguration = jpcb.build();
            //单机配置 + 客户端配置 = jedis连接工厂
            return new JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration);
        }
    
    
        @Bean
        public RedisTemplate<String, Object> objectRedisTemplate(RedisConnectionFactory factory)throws Exception {
            RedisTemplate<String, Object> template = new RedisTemplate<>();
            template.setConnectionFactory(factory);
    
            GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
            // 设置值（value）的序列化采用FastJsonRedisSerializer。
            template.setValueSerializer(jackson2JsonRedisSerializer);
            //        redisTemplate.setHashValueSerializer(fastJsonRedisSerializer);
            // 设置键（key）的序列化采用StringRedisSerializer。
            template.setKeySerializer(new StringRedisSerializer());
            template.setHashKeySerializer(new StringRedisSerializer());
            template.afterPropertiesSet();
    
            return template;
        }
    }
    

测试：

    
    
    public class RedisTest {
        @Autowired
        private RedisTemplate<String,Object> template;
    
        @Test
        public void test1(){
            ValueOperations<String, Object> operations = template.opsForValue();
            // 加上emp:在redis中分文件夹存储
            operations.set("emp:emp-01",new Employee(1,"aa"));
            System.out.println("存储成功！");
        }
    
        @Test
        public void test2(){
            ValueOperations<String, Object> operations = template.opsForValue();
            // 查询要与存入的key一致
            Employee emp = (Employee) operations.get("emp:emp-02");
            System.out.println(emp);
        }
    
    	// 查询所有emp
        @Test
        public void test3(){
        	// 获取所有emp:前缀的的key
            Set<String> keys = template.keys("emp:*");
            
            // 使用RedisTemplate查询所有的key
            if (keys != null) {
                List<Object> list = template.opsForValue().multiGet(keys);
                System.out.println(list);
            }
        }
    }
    
    

