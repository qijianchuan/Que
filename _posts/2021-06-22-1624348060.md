---
title: 高并发之——应用级缓存
categories: 精通高并发系列
tags: 高并发 应用级缓存
---
### 一、缓存命中率

缓存命中率是从缓存中读取数据的次数与总读取次数的比率，命中率越高越好。缓存命中率=从缓存中读取次数 / (总读取次数 (从缓存中读取次数 +
从慢速设备上读取次数))。这是一个非常重要的监控指标，如果做缓存，则应通过监控这个指标来看缓存是否工作良好。

### 二、缓存回收策略

**1.基于空间**  
基于空间指缓存设置了存储空间，如设置为10MB，当达到存储空间上限时，按照一定的策略移除数据。  
 **2.基于容量**  
基于容量指缓存设置了最大大小，当缓存的条目超过最大大小时，按照一定的策略移除旧数据。  
 **3.基于时间**  
TTL(Time To Live):存活期，即缓存数据从创建开始直到到期的一个时间段（不管在这个时间段内有没有被访问，缓存数据都将过期）。  
TTI(Time To Idle)：空闲期，即缓存数据多久没被访问后移除缓存的时间。  
 **4.基于对象引用**  
软引用：如果一个对象是软引用，则当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。  
弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将它立即回收。相对于软引用，弱引用有更短的生命周期。

注意：只有在没有其他强引用对象引用弱引用/软引用对象时，垃圾回收时才回收该引用。即如果有一个对象（不是弱引用/软引用对象）引用了弱引用/软引用对象，那么垃圾回收时不会回收该弱引用/软引用对象。  
 **5.回收算法**  
使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，常见的如下。  
-FIFO(First In First Out)：先进先出算法，即先放入缓存的先被移除。  
-LRU(Least Recently Used)：最近最少使用算法，时间时间距离现在最久的那个被移除。  
-LFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。  
实际应用中基于LRU的缓存居多。

### 三、缓存类型

堆内存：使用Java堆内存来存储对象。使用堆缓存的好处是没有序列化/反序列化，是最快的缓存。缺点也很明显，当缓存的数据量很大时，GC（垃圾回收）暂停时间会变长，存储容量受限于堆空间大小。一般通过软引用/弱引用来存储缓存对象。即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。可以使用Guava
Cache、Ehcache 3.x、 MapDB实现。

**堆外内存：**
即缓存数据存储在堆外内存，可以减少GC暂停时间（堆对象转移到堆外，GC扫描和移动的对象变少了），可以支持更多的缓存空间（只受机器内存大小限制，不受堆空间的影响）。但是，读取数据时需要序列化/反序列化。因此，会比堆缓存慢很多。可以使用Ehcache
3.x、 MapDB实现。

**磁盘缓存：** 即缓存数据存储在磁盘上，在JVM重启时数据还存在，而堆/堆外缓存数据会丢失，需要重新加载。可以使用Ehcache
3.x、MapDB实现。

**分布式缓存：** 分布式缓存可以使用ehcache-clustered(配合Terracotta
server)实现Java进程间分布式缓存。也可以使用Memcached、Redis实现。

**两种模式如下：**

  * 单机模式：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据到磁盘缓存。
  * 集群模式：存储最热的数据到堆缓存，相对热的数据到对外缓存，全量数据到分布式缓存。

