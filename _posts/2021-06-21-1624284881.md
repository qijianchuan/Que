---
title: JAVA发送接收MQ代码示例
categories: 其他
tags: MQQueue javaMQ MQUtils java发送MQ java接收MQ
---
上几篇关于MQ的博客里，并没有介绍的透彻，今天我把用到的类整理到里一起，集成了监视、查找、发送、接收、保存报文的功能。

首先，新建TemoteTest类

申明：

    
    
    	private static MQQueueManager qMgr; // 队列管理器名称
    	private static MQQueue qQueue; // 消息通道
    	private static String Q_MANAGER; // QueueManager名
    	private static String HOST_NAME; // 主机名
    	private static int PORT; // 端口号
    	private static String MQ_NAME; // 本地队列
    	private static String CHANNEL; // 连接通道
    	private static int CCSID; // 字符集
    
    	public static String dir = "C:/Users/admin/Desktop/远程测试报文/";
    

在桌面新建一个名为【远程测试报文】的文件夹，作为数据源。

    
    
    	/**
    	 * 循环所有文件发送
    	 * @param pa
    	 * @throws Exception
    	 */
    	public static void search(File pa) throws Exception
    	{
    		File[] fs = pa.listFiles();
    		for (int i = 0; i < fs.length; i++)
    		{
    			if (fs[i].isDirectory())
    			{
    				search(fs[i]);
    			}
    			StringBuffer sb = new StringBuffer();
    			Reader rd = null;
    			try
    			{
    				rd = new FileReader(fs[i]);
    			} catch (FileNotFoundException e)
    			{
    				e.printStackTrace();
    			}
    			char[] cr = new char[20348];
    			try
    			{
    				while (rd.read(cr) > -1)
    				{
    					sb.append(new String(cr));
    				}
    			} catch (IOException e)
    			{
    				e.printStackTrace();
    			}
    			sendMsg(sb.toString());
    		}
    	}
    

在这个方法中，将文件夹里所有文件都拿到，并将它读成字符串，再调用sendMsg()方法。

关于MQ初始化的方法：

    
    
    	/**
    	 * 初始化
    	 */
    	private static void init()
    	{
    		Properties prop = new Properties();
    		InputStream is = RemoteTest.class.getResourceAsStream("/constant.properties");
    		try
    		{
    			prop.load(is);
    			Q_MANAGER = prop.getProperty("Q_MANAGER").trim();
    			HOST_NAME = prop.getProperty("HOST_NAME").trim();
    			PORT = Integer.parseInt(prop.getProperty("PORT").trim());
    			MQ_NAME = prop.getProperty("MQ_NAME").trim();
    			CHANNEL = prop.getProperty("CHANNEL").trim();
    			CCSID = Integer.parseInt(prop.getProperty("CCSID").trim());
    
    			MQEnvironment.hostname = HOST_NAME;
    			MQEnvironment.port = PORT;
    			MQEnvironment.channel = CHANNEL;
    			MQEnvironment.CCSID = CCSID;
    
    			qMgr = new MQQueueManager(Q_MANAGER);
    			int qOptioin = MQC.MQOO_INPUT_AS_Q_DEF | MQC.MQOO_INQUIRE | MQC.MQOO_OUTPUT;
    			qQueue = qMgr.accessQueue(MQ_NAME, qOptioin);
    		} catch (IOException e)
    		{
    			e.printStackTrace();
    		} catch (MQException e)
    		{
    			e.printStackTrace();
    		}
    	}
    

这里可以直接把这些常量写死，不过不建议这样做。  
如果在同一台机器上测试，ip可以填写127.0.0.1  
在我的机器上它是这样子的：

    
    
    #队列管理器名称
    Q_MANAGER = SEND
    #主机
    HOST_NAME = 127.0.0.1
    #端口
    PORT = 1414
    #队列
    MQ_NAME = QUEUE
    #通道
    CHANNEL = CHANNEL
    CCSID = 1383
    

发送消息的方法：

    
    
    	/**
    	 * 发送消息
    	 */
    	public static void sendMsg(String msgStr)
    	{
    		try
    		{
    			init();
    			MQMessage qMsg = new MQMessage();
    			qMsg.encoding = CCSID;
    			qMsg.characterSet = CCSID;
    			qMsg.writeString(msgStr);
    			MQPutMessageOptions pmo = new MQPutMessageOptions();
    			qQueue.put(qMsg, pmo);
    			System.out.println("发送成功");
    		} catch (MQException e)
    		{
    			System.out.println("发生了一起异常，异常原因：" + e.reasonCode);
    		} catch (IOException e)
    		{
    			System.out.println("发生了一起IO异常：" + e.getMessage());
    		} finally
    		{
    			finalizer();
    		}
    	}
    

最后释放：

    
    
    	/**
    	 * 手动释放
    	 */
    	private static void finalizer()
    	{
    		try
    		{
    			qQueue.close();
    			qMgr.disconnect();
    		} catch (MQException e)
    		{
    			System.out.println("发生了一起异常，错误代码：" + e.reasonCode);
    			e.printStackTrace();
    		}
    	}
    

OK，接下来，Main方法中：

    
    
    public static void main(String[] args) throws Exception
    	{
    		File path = new File(dir);
    		search(path);
    	}
    

右键-Run以下，提示发送成功，可以在MQ客户端先查看以下消息队列深度。

由于在写博客的时候，我只能在家里的业余时间写，所以环境不允许，没办法截图，不过所有的代码都是经得起考验的可放心使用。

接下来，接收方法：

    
    
    	/**
    	 * 接收消息
    	 * 
    	 * @return
    	 */
    	public static String getMsg()
    	{
    		final MQMessage revMessage = new MQMessage();
    		try
    		{
    			init();
    			MQGetMessageOptions gmo = new MQGetMessageOptions();
    			revMessage.characterSet = CCSID;
    			revMessage.encoding = CCSID;
    			gmo.options += MQC.MQPMO_SYNCPOINT;
    			if (qQueue.getCurrentDepth() <= 0)
    			{
    				System.out.println("当前队列深度为0，队列中没有消息。");
    				return null;
    			}
    			qQueue.get(revMessage, gmo);
    			String revString = revMessage.readStringOfByteLength(revMessage.getMessageLength());
    			saveToXml(revString, System.currentTimeMillis());
    			return revString;
    		} catch (MQException e)
    		{
    			if (e.reasonCode == 2033) // 没有消息
    			{
    				System.out.println("没收到消息！");
    			}
    		} catch (IOException e)
    		{
    			e.printStackTrace();
    		} finally
    		{
    			finalizer();
    		}
    		return null;
    	}
    

查看了MQ文档，发现错误代码2033是空消息。当然那一段异常代码可以删掉了，因为在try方法中，我们首先判断了队列深度，如果队列深度为0，那就返回null，。所以2033异常应该是没有效果的。在来看一下保存文件：

    
    
    	/**
    	 * 保存文件
    	 * 
    	 * @param content
    	 *            报文
    	 * @param number
    	 *            时间戳
    	 */
    	private static void saveToXml(String content, long  name)
    	{
    		FileWriter fw;
    		String path = "C:/Users/admin/Desktop/远程测试报文2/";
    		File filePath = new File(path);
    		if (!filePath.exists())
    		{
    			filePath.mkdirs();
    		}
    		try
    		{
    			File newFile = new File("C:/Users/admin/Desktop/远程测试报文2/" + name + ".xml");
    			if (!newFile.exists())
    			{
    				fw = new FileWriter("C:/Users/admin/Desktop/远程测试报文2/" + name + ".xml");
    			} else 
    			{
    				fw = new FileWriter("C:/Users/admin/Desktop/远程测试报文2/" + name + "2" + ".xml");
    			}
    			fw.write(content);
    			fw.flush();
    			fw.close();
    		} catch (IOException e)
    		{
    			e.printStackTrace();
    		}
    	}
    	
    

然后在main方法中，调用：

    
    
    		while(true)
    		{
    			getMsg();
    		}
    

将所有报文保存成xml格式，这个只是我项目里的需求，大家在开发中根据需求自己修改修改就可以用了。

下载地址：http://download.csdn.net/download/u012552275/9815601  
（注：在下载的类中，和本章的代码稍有不同，下载好的类里，保存文件的格式是用报文里的节点截取的，在开发中大家直接将本章的保存代码稍加替换就可以使用了。）

自此，博客将不再更新有关MQ的知识。  
有什么不懂的地方，欢迎留言，或者加群159143965

WebSphere MQ使用：http://blog.csdn.net/u012552275/article/details/70194285

使用JAVA代码发送MQ消息：http://blog.csdn.net/u012552275/article/details/70194644

JAVA发送接收MQ代码示例：http://blog.csdn.net/u012552275/article/details/70194969

* * *

