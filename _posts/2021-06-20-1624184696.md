---
title: SpringBoot整合Redis
categories: java  初级
tags: java jedis
---
# SpringBoot整合Redis

## 1.pom依赖

    
    
    <!--redis依赖配置-->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    

## 2.aplication.yml配置

    
    
    server:
      port: 8080
    
    spring:
      redis:
        host: localhost # Redis服务器地址
        database: 0 # Redis数据库索引（默认为0）
        port: 6379 # Redis服务器连接端口
        password: # Redis服务器连接密码（默认为空）
        jedis:
          pool:
            max-active: 8 # 连接池最大连接数（使用负值表示没有限制）
            max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）
            max-idle: 8 # 连接池中的最大空闲连接
            min-idle: 0 # 连接池中的最小空闲连接
        timeout: 3000ms # 连接超时时间（毫秒）
    
    # 自定义redis key
    redis:
      key:
        prefix:
          authCode: "portal:authCode:"
        expire:
          authCode: 120 # 验证码超期时间
    

## 3.测试案例

redis数据类型借鉴案例：https://www.jianshu.com/p/475b800b56b7

    
    
    @SpringBootTest(classes = TingAPP.class)
    @RunWith(SpringRunner.class)
    public class RedisTest {
        @Autowired
        private StringRedisTemplate stringRedisTemplate;
    
        @Test
        public void tinyTest() throws InterruptedException {
    
        //数据类型
       /* @Test
        public void myTest(){
            //1.string
            stringRedisTemplate.opsForValue().set("name","zhangsan");
            stringRedisTemplate.opsForValue().get("name");
            stringRedisTemplate.opsForValue().set("age","23");
            stringRedisTemplate.opsForValue().increment("age",3);
            strin*//*gRedisTemplate.opsForValue().set("age","5",5,TimeUnit.SECONDS);//直接设置过期时间
            stringRedisTemplate.expire("age",5,TimeUnit.SECONDS);//设置已知key 过期时间
            stringRedisTemplate.delete("name");
    
            //2.hash 底层是hash 少量数据：类数组 大量数据：hashmap
            stringRedisTemplate.opsForHash().put("china","henan","zhengzhou");
            Object o = stringRedisTemplate.opsForHash().get("china", "henan");
            stringRedisTemplate.opsForHash().delete("china","henan");
    
            //3.list 底层：双向链表 有序
            stringRedisTemplate.opsForList().rightPush("name","zhangsan");
            stringRedisTemplate.opsForList().rightPop("name");
            stringRedisTemplate.opsForList().rightPush("age","23");
            stringRedisTemplate.opsForList().range("age",0,1);
            stringRedisTemplate.opsForList().remove("name",1,"zhangsan");
    
            //4.set 底层是hash，查询高效，value不重复
            stringRedisTemplate.opsForSet().add("name","zhangsan");
            //返回集合中所有成员
            Set<String> name = stringRedisTemplate.opsForSet().members("name");
            //移除并返回一个随机元素
            String name1 = stringRedisTemplate.opsForSet().pop("name");
            //遍历set
            Cursor<String> name2 = stringRedisTemplate.opsForSet().scan("name", ScanOptions.NONE);
            while(name2.hasNext()){
                System.out.println(name2.next());
            }
            //set集合 交 并 差
            String[] city1 = new String[]{"北京", "上海", "广州", "深圳", "昆明"};
            String[] city2 = new String[]{"北京", "深圳", "昆明", "成都"};
            stringRedisTemplate.opsForSet().add("city1",city1);
            stringRedisTemplate.opsForSet().add("city2",city2);
            //方式一
            //交集
            Set<String> intersect = stringRedisTemplate.opsForSet().intersect("city1", "city2");
            //并集
            Set<String> union = stringRedisTemplate.opsForSet().union("city1", "city2");
            //差集
            Set<String> difference = stringRedisTemplate.opsForSet().difference("city1", "city2");
            //求交集、并集、差集（方式二）
            stringRedisTemplate.opsForSet().intersectAndStore("citySet1","citySet2", "intersectCity");
            stringRedisTemplate.opsForSet().unionAndStore("citySet1","citySet2", "unionCity");
            stringRedisTemplate.opsForSet().differenceAndStore("citySet1","citySet2", "differenceCity");
            System.out.println("求交集、并集、差集（方式二）:");
            System.out.println("交集：" + stringRedisTemplate.opsForSet().members("intersectCity"));
            System.out.println("并集：" + stringRedisTemplate.opsForSet().members("unionCity"));
    
            //5.有序集合 zset 成员不重复
            ZSetOperations.TypedTuple<String> objectTypedTuple1 = new DefaultTypedTuple<>("pan_junbiao的博客_01",9.6);
            ZSetOperations.TypedTuple<String> objectTypedTuple2 = new DefaultTypedTuple<>("pan_junbiao的博客_02",1.5);
            ZSetOperations.TypedTuple<String> objectTypedTuple3 = new DefaultTypedTuple<>("pan_junbiao的博客_03",7.4);
            Set<ZSetOperations.TypedTuple<String>> typles = new HashSet<ZSetOperations.TypedTuple<String>>();
            typles.add(objectTypedTuple1);
            typles.add(objectTypedTuple2);
            typles.add(objectTypedTuple3);
            stringRedisTemplate.opsForZSet().add("typles",typles);
            stringRedisTemplate.opsForZSet().range("typles",0,-1);
            //移除元素
            stringRedisTemplate.opsForZSet().remove("typles");
            stringRedisTemplate.opsForZSet().remove("typles","hehe");
            //返回指定成员排名
            stringRedisTemplate.opsForZSet().rank("typles","hehe");
            //取出索引区间内成员，默认按分值小到大
            System.out.println(stringRedisTemplate.opsForZSet().range("zset5",0,-1));
            //取出索引区间内成员，默认按分值大到小
            System.out.println(stringRedisTemplate.opsForZSet().rangeByScore("zset5", 0, 8));
    
            System.out.println("分数在0至8区间内的成员个数：" + stringRedisTemplate.opsForZSet().count("zset6", 0, 8));
            System.out.println("有序集合的成员数：" + stringRedisTemplate.opsForZSet().size("zset6"));
            //获取指定成员score值
            stringRedisTemplate.opsForZSet().add("zset7", "pan_junbiao的博客_03", 7.4);
            System.out.println("pan_junbiao的博客_01的分数：" + stringRedisTemplate.opsForZSet().score("zset7", "pan_junbiao的博客_01"));
            //移除指定范围数据
            System.out.println(stringRedisTemplate.opsForZSet().removeRange("zset8", 1, 5));
            //遍历zset
            System.out.println(stringRedisTemplate.opsForZSet().add("zset9", typles));
            Cursor<ZSetOperations.TypedTuple<String>> cursor = stringRedisTemplate.opsForZSet().scan("zset9", ScanOptions.NONE);
            while (cursor.hasNext()) {
                ZSetOperations.TypedTuple<String> item = cursor.next();
                System.out.println(item.getValue() + " 的分数值：" + item.getScore());
            }
        }
    
        //统计页面uv
        @Test
        public void testPlaus(){
    
            List<Long> userIds=new ArrayList<>();
            for (long i = 0; i < 10000; i++) {
                userIds.add(i);
            }
    
            //方案一 Set key=PageID_日期 value用户id 由于set数据不重复，所以不会重复统计用户访客记录
            String key="1:uv";
            BoundSetOperations<String, String> bound = stringRedisTemplate.boundSetOps(key);
            userIds.forEach(id->{
                bound.add(String.valueOf(id));
            });
            //获得size
            System.out.println("set size:"+bound.size());
    
            //方案二 Bitmap id是整形且连续自增
            userIds.forEach(id->{
                stringRedisTemplate.opsForValue().setBit(key,id,true);
            });
            //获得size
            System.out.println("bitmap size:"+stringRedisTemplate.execute((RedisCallback<Long>) con -> con.bitCount(key.getBytes())));
    
            //方案三 HyperLogLog 提供不精确去重计数方案，每个key仅需12kb,元素不能直接提取，标准误差大概在0.81
            userIds.forEach(id->{
                stringRedisTemplate.opsForHyperLogLog().add(String.valueOf(id));
            });
            //获得size
            System.out.println("HyperLogLog size:"+stringRedisTemplate.opsForHyperLogLog().size(key));
    
        }
    
        //千万级用户，统计签到情况
        @Test
        public void testPlaus2(){
            Long userId =1000L;
            String key="sigin:"+userId+"202104";
    
            for (int i = 0; i <= 30; i++) {
                //日期被2整除模拟为签到
                stringRedisTemplate.opsForValue().setBit(key,i,i%2==0? true:false);
            }
    
            //获取当月登录总天数
            Long size = stringRedisTemplate.execute((RedisCallback<Long>) con -> con.bitCount(key.getBytes()));
            //获取每天登录情况
            for (int i = 0; i <=30; i++) {
                Boolean bit = stringRedisTemplate.opsForValue().getBit(key, i);
                System.out.println("2021/4/"+i+" "+bit);
            }
        }*/
    }
    

