---
title: MongoDB之——MapReduce
categories: 精通分布式数据库系列
tags: MongoDB
---
转载请注明出处：https://blog.csdn.net/l1028386804/article/details/79995723  

### 1、MongoDB MapReduce简述与数据准备

MongoDB 的 MapReduce 相当于 Mysql 中的"group by"，所以在MongoDB上使用
Map/Reduce进行并行"统计"很容易。  
使用 MapReduce 要实现两个函数 Map 函数和 Reduce 函数， Map 函数调用 emit(key, value)，遍历
collection中所有的记录，将 key与value传递给 Reduce 函数进行处理。Map函数和 Reduce函数可以使用 JavaScript
来实现，可以通过 db.runCommand 或 mapReduce 命令来执行一个MapReduce 的操作：  

    
    
    db.runCommand(
      { mapreduce : <collection>,
        map : <mapfunction>,
        reduce : <reducefunction>
        [, query : <query filter object>]
        [, sort : <sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces>]
        [, limit : <number of objects to return from collection>]
        [, out : <see output options below>]
        [, keeptemp: <true|false>]
        [, finalize : <finalizefunction>]
        [, scope : <object where fields go into javascript global scope >]
        [, verbose : true]
      }
    );

参数说明:  

  * mapreduce: 要操作的目标集合。
  * map: 映射函数 (生成键值对序列，作为 reduce 函数参数)。
  * reduce: 统计函数。
  * query: 目标记录过滤。
  * sort: 目标记录排序。
  * limit: 限制目标记录数量。
  * out: 统计结果存放集合 (不指定则使用临时集合，在客户端断开后自动删除)。
  * keeptemp: 是否保留临时集合。
  * finalize: 最终处理函数 (对 reduce 返回结果进行最终整理后存入结果集合)。
  * scope: 向 map、 reduce、 finalize 导入外部变量。
  * verbose: 显示详细的时间统计信息。

下面我们先准备一些数据:  

    
    
    > db.students.insert({classid:1, age:14, name:'Tom'})
    > db.students.insert({classid:1, age:12, name:'Jacky'})
    > db.students.insert({classid:2, age:16, name:'Lily'})
    > db.students.insert({classid:2, age:9, name:'Tony'})
    > db.students.insert({classid:2, age:19, name:'Harry'})
    > db.students.insert({classid:2, age:13, name:'Vincent'})
    > db.students.insert({classid:1, age:14, name:'Bill'})
    > db.students.insert({classid:2, age:17, name:'Bruce'})
    >

接下来，我们将演示如何统计 1 班和 2 班的学生数量  

### 2、Map

Map 函数必须调用 emit(key, value) 返回键值对，使用 this 访问当前待处理的 Document。  

    
    
    > m = function() { emit(this.classid, 1) }
    function () {
    emit(this.classid, 1);
    }
    >

value 可以使用 JSON Object 传递 (支持多个属性值)。例如:  

    
    
    emit(this.classid, {count:1})

### 3、Reduce

Reduce 函数接收的参数类似 Group 效果，将 Map 返回的键值序列组合成 { key, [value1,value2, value3,
value...] } 传递给 reduce。  

    
    
    > r = function(key, values) {
    ... var x = 0;
    ... values.forEach(function(v) { x += v });
    ... return x;
    ... }
    function (key, values) {
    var x = 0;
    values.forEach(function (v) {x += v;});
    return x;
    }
    >

Reduce 函数对这些 values 进行 "统计" 操作，返回结果可以使用 JSON Object。  

### 4、Result

    
    
    > res = db.runCommand({
    ... mapreduce:"students",
    ... map:m,
    ... reduce:r,
    ... out:"students_res"
    ... });
    {
    "result" : "students_res",
    "timeMillis" : 1587,
    "counts" : {
    "input" : 8,
    "emit" : 8,
    "output" : 2
    },
    "ok" : 1
    }
    > db.students_res.find()
    { "_id" : 1, "value" : 3 }
    { "_id" : 2, "value" : 5 }
    >

mapReduce() 将结果存储在 "students_res" 表中。  

### 5、Finalize

利用 finalize() 我们可以对 reduce() 的结果做进一步处理。  

    
    
    > f = function(key, value) { return {classid:key, count:value}; }
    function (key, value) {
    return {classid:key, count:value};
    }
    >

我们再重新计算一次，看看返回的结果:  

    
    
    > res = db.runCommand({
    ... mapreduce:"students",
    ... map:m,
    ... reduce:r,
    ... out:"students_res",
    ... finalize:f
    ... });
    {
    "result" : "students_res",
    "timeMillis" : 804,
    "counts" : {
    "input" : 8,
    "emit" : 8,
    "output" : 2
    },
    "ok" : 1
    }
    > db.students_res.find()
    { "_id" : 1, "value" : { "classid" : 1, "count" : 3 } }
    { "_id" : 2, "value" : { "classid" : 2, "count" : 5 } }
    >

列名变与 “classid”和”count”了，这样的列表更容易理解。  

### 6、Options

我们还可以添加更多的控制细节。  

    
    
    > res = db.runCommand({
    ... mapreduce:"students",
    ... map:m,
    ... reduce:r,
    ... out:"students_res",
    ... finalize:f,
    ... query:{age:{$lt:10}}
    ... });
    {
    "result" : "students_res",
    "timeMillis" : 358,
    "counts" : {
    "input" : 1,
    "emit" : 1,
    "output" : 1
    },
    "ok" : 1
    }
    > db.students_res.find();
    { "_id" : 2, "value" : { "classid" : 2, "count" : 1 } }
    >

可以看到先进行了过滤，只取 age<10 的数据，然后再进行统计，所以就没有 1 班的统计数据了。  

  

