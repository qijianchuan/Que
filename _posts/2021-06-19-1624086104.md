---
title: 延迟消息任务（指定间隔定时任务）模块设计及实现
categories: 设计 从零开始搭建后台框架到放弃
tags: 
---
# 概述

在系统中总是存在需要设置指定某件事在指定的时间间隔之后发生。一般来说，我们希望使用定时任务或者延迟消息来处理这些事情，但是，这里存在几个问题。这些问题就要说道我们产生这个需求的具体场景了————检测单元离线。

# 设计

## 需求

检测单元是我们的设备名称，监测单元会上报数据，也会在指定间隔上报心跳数据。如果我们在一个时间段没有在收到上报的数据，我们就认为监测单元离线了，目前这个时间是48小时。我之前的公司，都是定时跑批来检测这种数据的，否则，我们就只能查看这个设备是否离线。而这次，我们希望可以在设备离线的时候能够收到通知，以便进行通知，以相关的业务处理。传统来数，我们会想到quartz或者spring的定时任务。他们就是都可以做这件事，但是，分布式的场景就有点讨厌了，spring的定时任务在分布式场景也是使用的quartz，是使用数据库进行中央调度的。而且，还有个问题是，我们无法使用一个定时任务来处理所有的检测单元，而是需要每个检测单元都有一个自己的过期时间。  
另外的问题是，每次在未离线时收到消息的话，对应的检测单元需要将自己的离线时间进行推迟，如果有必要我们还要可以删除这个任务。这个虽然我没有细看quartz的api，只是查了很多常规的用法，感觉quartz对这种操作并不友好。而且，检测单元在未来的数量级至少是十万起步的，对于这种规模的数据每个都进行定时的话，总觉得使用数据库是一种很笨重的选择。所以，我们选择使用redis的key的过期通知（考虑过mongodb，但是曾经用mongodb的过期总是有半分钟左右的偏差，所以就还是使用redis了，另外系统中已经引入redis了，这里就不引入过多的技术了）。  
另外，这种key的过期有一个先天的问题，就是它的通知是广播出去的。也就是，如果我有多个进程的话，每个进程都会收到这个消息，这在初期的时候就出现了离线数据存入多条的问题，这个问题也是必须解决的。

## 解决思路

首先，使用redis的过期机制，可以达到对大规模的监测单元的离线管理的目的。现在，唯一存在的问题是，过期通知是广播出去的，需要让服务只执行一次。  
这个问题的解决基本思路就是加锁，让所有进程去争夺这个锁，抢到的就执行这个任务。锁的可以有两种方式设立：

  1. 使用zookeeper做仲裁
  2. 争夺一个公共资源  
由于zookeeper的api我并没有详细看过，对于仲裁过程，直觉上感觉它需要消耗很多资源，所以，我们采用的是第二种方式，我们在redis中设立一个锁，利用redis先天单线程的便利，来做锁。具体来说，在每次插入和更新超时任务时，我们在redis中插入一个指定的值，在出发超时通知时，先去删除这个key，删除成功的进程继续执行后面的任务，没抢到的就不执行了。

# 实现

这个功能考虑到多个项目都可能使用到，所以我们把它放到了core包里，具体的报名就是com.ym.core.redis.interval
这个包里，我们只用三个类就实现了这个功能：

  * ExpiredListener : 这是JedisPubSub的一个子类，是离线消息的监听者，由于redis的逻辑是一个监听者会收到一个db里的所有过期通知，所以，实际上是由listener收到消息，路由给具体处理业务逻辑的处理者，这个处理者就是后面提到的ExpireManager
  * ExpireManager : 具体过期业务逻辑的实现者，这个类只是一个抽象类，使用者必须派生自己的类，实现自己的业务逻辑。
  * InternalScheduleManager : 对上述两种对象的实例进行管理，也是对外的统一公共接口，对该模块的生命周期负责。

## ExpiredListener

该类是实际监听redis过期消息的类，同时，该类还负责将收到的消息路由给对应的ExpireManager进行处理。所以，首先是，ExpiredListener监听的范围和路由的范围，这两个内容我们都在构造函数中传入：

    
    
    public ExpiredListener(String pattern,Map<String,ExpireManager> expireManagerMap){
        this.pattern=pattern;
        this.expireManagerMap = expireManagerMap;
    }
    

虽然在redis的api中是允许同时监听多个pattern的，但是，考虑到我们的实际使用场景，这里就没有对监听多个db做考虑了，我们假设所有的都来自于某个db。  
构造好之后，其实就可以开始监听了，开启监听的代码也是非常简单的，我们直接提供了一个start方法用来外部调用。

    
    
    public void start(){
        this.getJedisPool().getResource().psubscribe(this,pattern);
    }
    

开启监听后，就需要处理收到的消息了，这是通过实现JedisPubSub的onPMessage方法来实现的。onPMessage有三个入参，其中我们现阶段最关心的是最后一个message，里面实际存储的是key的内容，而value的内容是获取不到的。所以，如果我们需要什么信息，就需要存储到key里面，而不是value里，这个是需要注意的。

    
    
        @Override
        public void onPMessage(String pattern, String channel, String message) {
            Jedis jedis=this.getJedisPool().getResource();
            try {
                //移除固定头之后的key的内容
                String handledKey=message.replace(
                        ExpireManager.TOPKEY+ExpireManager.SPLIT
                        ,""
                );
    
                for(ExpireManager expireManager: this.expireManagerMap.values()){
                    //如果该过期过滤器该执行该消息回调的话
                    if(expireManager.filter(handledKey)){
                        //选择对应的数据库
                        jedis.select(InternalScheduleManager.getInstance().getDb());
                        //尝试删除hashmap中的指定key
                        long result= jedis.hdel(InternalScheduleManager.getInstance().getLockTableKey(),message);
                        //如果删除键时键不存在，则不执行回调
                        if(result==0){
                            return;
                        }
    
                        //调用回调
                        expireManager.callback(pattern, channel, message);
                    }
                }
    
            }catch (Exception ex){
                StringBuilder errMsg=new StringBuilder();
                errMsg.append("pattern:");
                errMsg.append(pattern);
                errMsg.append("\n");
                errMsg.append("channel:");
                errMsg.append(channel);
                errMsg.append("\n");
                errMsg.append("message:");
                errMsg.append(message);
                errMsg.append("\n");
                errMsg.append("redis回调报错：");
                errMsg.append(ex.getMessage());
    
                logger.error(errMsg.toString());
            }finally{
                if(jedis!=null){
                    jedis.close();
                }
            }
        }
    

由于过期的单元只能是redis的key，不可以是hashmap的field，所以，为了方便管理，我们给所有这个模块添加的key都添加了指定的头，为了方便处理，我们在收到后，把指定的头移除之后再丢给后面的业务。然后，我们就从所有的ExpireManager中找到处理这个消息的，找到之后，我们通过删除我们用来做锁的资源，删除成功就处理后续内容，否则就到此结束了。需要注意的是，由于我们这里是在一个独立的线程里，所以需要拦截掉所有的异常，以确保监听线程的稳定。另外，需要总是关闭jedis连接资源。之前我们发生或JedisPool资源使用完，没有回收，导致操作几次之后系统就卡死了，因为分配不到资源。

## ExpireManager

该类针对某个具体的过期监听业务来说，是完成所有操作的类。我们分几个部分来展示下这个类的代码，首先是常量：

    
    
    //最顶层的key头
    public static final String TOPKEY="schedule:interval";
    //分隔符
    public static final String SPLIT=":";
    

然后是需要实现的几个虚方法：

    
    
    /**
        * 获取需要执行回调的键值的前缀
        * @return
        */
    public abstract String getKeyHeader();
    
    /**
        * 过期时间，单位：秒
        * @return 键值过期需要的秒数
        */
    protected abstract int getExpireSeconds();
    
    /**
        * 判断key是否是需要自己处理的key
        * @param key 移除公共头之后的key值
        * @return 如果是自己需要处理的则返回true，否则返回false
        */
    public abstract boolean filter(String key);
    

这几个方法普遍都是整体逻辑必备但是又需要用户指定具体内容的方法，用户需要对其进行具体实现。

    
    
    /**
        * 生成需要的key
        * @param content 由于在回调中
        * @return
        */
    private String generateKey(String content){
    
        return TOPKEY+SPLIT+this.getKeyHeader()+SPLIT+content;
    }
    
    /**
        * 存入对应的key值，执行完成后将会生成对应时间过期的键值，同时生成对应的分布式锁
        * @param keyContent 业务对该内容的key的编码
        */
    public void putKey(String keyContent){
        InternalScheduleManager.getInstance().putMsg(this.generateKey(keyContent),this.getExpireSeconds());
    }
    

这两个方法是构造需要的key以及创建对应的key的值所需要的方法。这对封装并不是很协调，因为需要用户使用generateKey创建完整的key然后在调用putKey，而用户其实并不知道也不能控制generateKey的逻辑，希望能够有更加透明的方法。  
最后是具体的回调逻辑：

    
    
    /**
        * 在收到对应的消息后，会回调该方法，开发者可以实现该方法并实现特定的业务逻辑
        * @param pattern 监听的模式
        * @param channel 具体的信道
        * @param message 对应的消息
        */
    public abstract void callback(String pattern, String channel, String message);
    

## InternalScheduleManager

该类是对该模块的全局生命周期和资源负责的类，所以，模块的初始化在它这里：

    
    
    /**
        * 对管理器进行初始化
        * @param db 监听的redis数据库的序号
        */
    public void init(int db){
        //获取所有的过期管理器
        Map<String,ExpireManager> expireManagerMap=new HashMap<>();
        Map<String,ExpireManager> expireManagers= YmContext.getBeans(ExpireManager.class);
        for(ExpireManager expireManager :expireManagers.values()){
            expireManagerMap.put(expireManager.getKeyHeader(),expireManager);
        }
    
        this.db=db;
    
        //声明一个过期订阅者
        ExpiredListener expiredListener=new ExpiredListener(this.getPattern(),expireManagerMap);
    
        //开启订阅线程
        Thread thread=new Thread(new Runnable() {
            @Override
            public void run() {
                expiredListener.start();
            }
        });
        thread.start();
        //存储线程
        this.callbackThread=thread;
    
    }
    

这里可以看到，我们获取到了，所有的ExpireManager，需要注意的是所有的需要生效的ExpireManager都应该被注册成了一个Bean。然后，启动一个监听者，再开启一个线程来进行监听。这就是该类的主逻辑，其余方法基本都是为了配合这些而创建的方法。只是有一个，存储key的核心方法：

    
    
    /**
        * 设置过期消息
        * @param key 需要处理的具体的值
        */
    public void putMsg(String key,int expireSeconds){
    
        String timestamp= String.valueOf(Calendar.getInstance().getTimeInMillis());
    
        Jedis jedis=this.getJedisPool().getResource();
    
        try {
    
            jedis.select(this.getDb());
            //存入分布式锁
            jedis.hset(this.getLockTableKey(), key, timestamp);
    
            //存入过期用key
            jedis.setex(key
                    , expireSeconds
                    , timestamp
            );
        }finally{
            if(jedis!=null){
                jedis.close();
            }
        }
    }
    

ExpireManager的发送方法实际是调用该方法实现的，以防止具体实现类篡改核心逻辑。

# 使用

  * 指定使用redis的哪个db
  * 创建自己的ExpireManager派生类，并注册为Bean
  * 在进程启动的时候调用 InternalScheduleManager.getInstance().init(redisDb)

需要注意的是，即使有多个ExpireManager也只需要初始化一遍。

